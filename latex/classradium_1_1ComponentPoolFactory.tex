\hypertarget{classradium_1_1ComponentPoolFactory}{}\doxysection{radium\+::Component\+Pool\+Factory Class Reference}
\label{classradium_1_1ComponentPoolFactory}\index{radium::ComponentPoolFactory@{radium::ComponentPoolFactory}}


Creates new component pools.  




{\ttfamily \#include $<$Component\+Pool\+Factory.\+h$>$}



Collaboration diagram for radium\+::Component\+Pool\+Factory\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=251pt]{classradium_1_1ComponentPoolFactory__coll__graph}
\end{center}
\end{figure}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classradium_1_1ComponentPoolFactory_ac3db2fb5662dfa910cab2ca08175f116}\label{classradium_1_1ComponentPoolFactory_ac3db2fb5662dfa910cab2ca08175f116}} 
{\footnotesize template$<$class T $>$ }\\\mbox{\hyperlink{classradium_1_1ComponentPool}{Component\+Pool}}$<$ T $>$ $\ast$ \mbox{\hyperlink{classradium_1_1ComponentPoolFactory_ac3db2fb5662dfa910cab2ca08175f116}{add\+New\+Pool}} ()
\begin{DoxyCompactList}\small\item\em Add Component\+Pool$<$\+T$>$ to the list of pools. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classradium_1_1ComponentPoolFactory_a089b69d47b37fbf4962fdba8211453b2}\label{classradium_1_1ComponentPoolFactory_a089b69d47b37fbf4962fdba8211453b2}} 
{\footnotesize template$<$class T $>$ }\\\mbox{\hyperlink{classradium_1_1ComponentPool}{Component\+Pool}}$<$ T $>$ $\ast$ \mbox{\hyperlink{classradium_1_1ComponentPoolFactory_a089b69d47b37fbf4962fdba8211453b2}{get}} ()
\begin{DoxyCompactList}\small\item\em Get pool storing T. The pool will be created if it does not exist. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classradium_1_1ComponentPoolFactory_a0da8c387cc1c8e52d334cf001d66ecb4}\label{classradium_1_1ComponentPoolFactory_a0da8c387cc1c8e52d334cf001d66ecb4}} 
\mbox{\hyperlink{classrtl_1_1unordered__map}{rtl\+::unordered\+\_\+map}}$<$ U64, \mbox{\hyperlink{structradium_1_1ComponentPoolContainer}{Component\+Pool\+Container}} $>$ {\bfseries m\+\_\+cpools}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Creates new component pools. 

These component pools are uniquely identified by the type index the compiler gives them

Creating a new pool\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{my\_poolfactory.addNewPool<MyComponent>();}

\end{DoxyCode}


Getting a pool, this will create it if it does not exist 
\begin{DoxyCode}{0}
\DoxyCodeLine{my\_poolfactory.get<MyComponent>();}

\end{DoxyCode}


How does this handle deletions, considering Component\+Pools need to free memory allocated by sparse\+\_\+sets et. al.?

This is handled via a very tricky trick using lambdas. Hopefully this will be refactored in the future...

Essentially, a new lambda is creating during compile time for each type the compiler detects. It\textquotesingle{}s job is to cast a pointer to Component\+Pool$<$\+T$>$ and delete it. This is needed because once a pool is stored, all associated type information is lost. 

The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
scene/ecs/Component\+Pool\+Factory.\+h\end{DoxyCompactItemize}
