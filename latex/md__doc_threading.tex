Headers are found in {\ttfamily /core/thread}, implementations are found in {\ttfamily /platform/$<$platform$>$/thread/}\hypertarget{md__doc_threading_autotoc_md14}{}\doxysection{Abstraction}\label{md__doc_threading_autotoc_md14}
There is a single object for each major threading component. Thes objects contain aliased types for each platform.

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{4}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Major Object   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type Name   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Windows Alias   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Linux Alias    }\\\cline{1-4}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Major Object   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type Name   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Windows Alias   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Linux Alias    }\\\cline{1-4}
\endhead
{\ttfamily thread}   &{\ttfamily Thread\+Object}   &{\ttfamily HANDLE}   &{\ttfamily pthread\+\_\+t}    \\\cline{1-4}
{\ttfamily Mutex}   &{\ttfamily Mutex\+Object}   &{\ttfamily HANDLE}   &{\ttfamily pthread\+\_\+mutex\+\_\+t}    \\\cline{1-4}
{\ttfamily Semaphore}   &{\ttfamily Semaphore Object}   &{\ttfamily HANDLE}   &{\ttfamily sem\+\_\+t}   \\\cline{1-4}
\end{longtabu}
\hypertarget{md__doc_threading_autotoc_md15}{}\doxysection{Creating a New Thread}\label{md__doc_threading_autotoc_md15}

\begin{DoxyCode}{0}
\DoxyCodeLine{ \{c++\}}
\DoxyCodeLine{}
\DoxyCodeLine{// creates a new thread. }
\DoxyCodeLine{// This will create a new thread for myfunction with myArg1 and myArg2}
\DoxyCodeLine{}
\DoxyCodeLine{radium::thread mythread(myfunction, myArg1, myArg2);}
\DoxyCodeLine{}
\DoxyCodeLine{// wait for the thread to exit}
\DoxyCodeLine{mythread.join()}

\end{DoxyCode}


{\ttfamily \mbox{\hyperlink{classradium_1_1thread}{radium\+::thread}}} can take any number/type of arguments so long as they match with the target functions prototpye\hypertarget{md__doc_threading_autotoc_md16}{}\doxysubsection{Backend}\label{md__doc_threading_autotoc_md16}
This is a bit tricky and will hopefully be refactored in the future.

When you create a new thread, it will use a dummy thread runner. This will run a global capturing lambda function that in turns runs {\ttfamily myfunction} with its arguments.

The extra overhead is 1 function call.\hypertarget{md__doc_threading_autotoc_md17}{}\doxysection{Mutexes and Thread Safe classes/functions}\label{md__doc_threading_autotoc_md17}
A mutex is very simple to create.


\begin{DoxyCode}{0}
\DoxyCodeLine{ \{C++\}}
\DoxyCodeLine{}
\DoxyCodeLine{radium::Mutex mymutex;}
\DoxyCodeLine{}
\DoxyCodeLine{mymutex.create();}
\DoxyCodeLine{}
\DoxyCodeLine{mymutex.lock()}
\DoxyCodeLine{}
\DoxyCodeLine{// critical section code}
\DoxyCodeLine{}
\DoxyCodeLine{mymutex.unlock()}

\end{DoxyCode}
\hypertarget{md__doc_threading_autotoc_md18}{}\doxysubsection{Thread Safe classes/functions}\label{md__doc_threading_autotoc_md18}
In {\ttfamily \mbox{\hyperlink{thread_8h_source}{thread.\+h}}} you will find three macros\+:
\begin{DoxyEnumerate}
\item {\ttfamily THREAD\+\_\+\+SAFE\+\_\+\+CLASS}
\item {\ttfamily THREAD\+\_\+\+SAFE\+\_\+\+FUNCTION}
\item {\ttfamily THREAD\+\_\+\+SAFE\+\_\+\+INIT}
\end{DoxyEnumerate}

Using these functions, you can create a thread safe class. Any functions that could possibly corrupt data under a race condition should be marked with {\ttfamily THREAD\+\_\+\+SAFE\+\_\+\+FUNCTION} Your class\textquotesingle{} constructor should contain {\ttfamily THREAD\+\_\+\+SAFE\+\_\+\+INIT}.

Example\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{ \{C++\}}
\DoxyCodeLine{class MyClassThatContainsCriticalCode}
\DoxyCodeLine{\{}
\DoxyCodeLine{    THREAD\_SAFE\_CLASS}
\DoxyCodeLine{}
\DoxyCodeLine{public:}
\DoxyCodeLine{    MyClassThatContainsCriticalCode()}
\DoxyCodeLine{    \{}
\DoxyCodeLine{        THREAD\_SAFE\_INIT}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{    int longFunction()}
\DoxyCodeLine{    \{}
\DoxyCodeLine{        ... this function doesn't need to be thread safe...}
\DoxyCodeLine{        return 0;}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{    int longFunctionThatModifiesSomething()}
\DoxyCodeLine{    \{}
\DoxyCodeLine{        THREAD\_SAFE\_FUNCTION}
\DoxyCodeLine{        ... modify something...}
\DoxyCodeLine{        return 0;}
\DoxyCodeLine{    \}}
\DoxyCodeLine{\};}

\end{DoxyCode}
\hypertarget{md__doc_threading_autotoc_md19}{}\doxysubsubsection{Best Practices}\label{md__doc_threading_autotoc_md19}

\begin{DoxyEnumerate}
\item Don\textquotesingle{}t put {\ttfamily THREAD\+\_\+\+SAFE\+\_\+\+FUNCTION} in the constructor
\item Don\textquotesingle{}t put {\ttfamily THREAD\+\_\+\+SAFE\+\_\+\+FUNCTION} anywhere such that it would be called recursively
\end{DoxyEnumerate}\hypertarget{md__doc_threading_autotoc_md20}{}\doxysubsubsection{Backend}\label{md__doc_threading_autotoc_md20}
There exists a clas called {\ttfamily \mbox{\hyperlink{classradium_1_1ScopedMutexLocker}{radium\+::\+Scoped\+Mutex\+Locker}}}

This will take your classes mutex, lock it during constructor, and unlock it during destruction (e.\+g. when the locker goes out of scope)\hypertarget{md__doc_threading_autotoc_md21}{}\doxysubsection{Mutex Backend}\label{md__doc_threading_autotoc_md21}
This is a thin wrapper over the Operating System\textquotesingle{}s Mutex API (i.\+e {\ttfamily Create\+Mutex}/{\ttfamily pthread\+\_\+mutex\+\_\+init}) 