\doxysection{Class List}
Here are the classes, structs, unions and interfaces with brief descriptions\+:\begin{DoxyCompactList}
\item\contentsline{section}{\mbox{\hyperlink{classstl_1_1array}{stl\+::array$<$ T $>$}} \\*Array to hold T data }{\pageref{classstl_1_1array}}{}
\item\contentsline{section}{\mbox{\hyperlink{classsimula24_1_1BaseSink}{simula24\+::\+Base\+Sink}} \\*Base class for logging strategies }{\pageref{classsimula24_1_1BaseSink}}{}
\item\contentsline{section}{\mbox{\hyperlink{classstl_1_1basic__string}{stl\+::basic\+\_\+string$<$ T $>$}} }{\pageref{classstl_1_1basic__string}}{}
\item\contentsline{section}{\mbox{\hyperlink{classstl_1_1Callable}{stl\+::\+Callable$<$ Ret\+Type, Args $>$}} \\*Base \mbox{\hyperlink{classstl_1_1Callable}{Callable}} class Used for type erasure }{\pageref{classstl_1_1Callable}}{}
\item\contentsline{section}{\mbox{\hyperlink{classstl_1_1CallableWrapper}{stl\+::\+Callable\+Wrapper$<$ Fn, Ret\+Type, Args $>$}} \\*Wrapper around callable }{\pageref{classstl_1_1CallableWrapper}}{}
\item\contentsline{section}{\mbox{\hyperlink{classsimula24_1_1ConsoleSink}{simula24\+::\+Console\+Sink}} \\*Sink that prints logs to stderr }{\pageref{classsimula24_1_1ConsoleSink}}{}
\item\contentsline{section}{\mbox{\hyperlink{structstl_1_1contains}{stl\+::contains$<$ T, Type $>$}} }{\pageref{structstl_1_1contains}}{}
\item\contentsline{section}{\mbox{\hyperlink{structstl_1_1contains_3_01T_00_01typelist_3_01Types_8_8_8_01_4_01_4}{stl\+::contains$<$ T, typelist$<$ Types... $>$ $>$}} \\*Test if a typelist contains a type }{\pageref{structstl_1_1contains_3_01T_00_01typelist_3_01Types_8_8_8_01_4_01_4}}{}
\item\contentsline{section}{\mbox{\hyperlink{classstl_1_1copy__on__write}{stl\+::copy\+\_\+on\+\_\+write$<$ T $>$}} \\*A template class that allows clients to ~\newline
 use copy-\/on-\/write. Use \mbox{\hyperlink{classstl_1_1copy__on__write_a520862481863bb8fce12cbb99d3f79a0}{copy()}} to create your own copy }{\pageref{classstl_1_1copy__on__write}}{}
\item\contentsline{section}{\mbox{\hyperlink{structstl_1_1copy__on__write_1_1CowHdr}{stl\+::copy\+\_\+on\+\_\+write$<$ T $>$\+::\+Cow\+Hdr}} \\*A nicer way of obtain header data }{\pageref{structstl_1_1copy__on__write_1_1CowHdr}}{}
\item\contentsline{section}{\mbox{\hyperlink{classsimula24_1_1DebugLoggers}{simula24\+::\+Debug\+Loggers}} }{\pageref{classsimula24_1_1DebugLoggers}}{}
\item\contentsline{section}{\mbox{\hyperlink{structstl_1_1displaced__pair}{stl\+::displaced\+\_\+pair$<$ K, V, Displacement\+Type $>$}} \\*A specialized KV pair for maps/tables using PSLs }{\pageref{structstl_1_1displaced__pair}}{}
\item\contentsline{section}{\mbox{\hyperlink{classsimula24_1_1dummy__thread__runner}{simula24\+::dummy\+\_\+thread\+\_\+runner}} \\*This is what is passed to the OS create thread function }{\pageref{classsimula24_1_1dummy__thread__runner}}{}
\item\contentsline{section}{\mbox{\hyperlink{classsimula24_1_1File}{simula24\+::\+File}} \\*Easy-\/to-\/use \mbox{\hyperlink{classsimula24_1_1File}{File}} access }{\pageref{classsimula24_1_1File}}{}
\item\contentsline{section}{\mbox{\hyperlink{classsimula24_1_1FileSink}{simula24\+::\+File\+Sink}} \\*Write logs to a file }{\pageref{classsimula24_1_1FileSink}}{}
\item\contentsline{section}{\mbox{\hyperlink{classstl_1_1function}{stl\+::function$<$ Signature $>$}} }{\pageref{classstl_1_1function}}{}
\item\contentsline{section}{\mbox{\hyperlink{classstl_1_1function_3_01Ret_07Args_8_8_8_08_4}{stl\+::function$<$ Ret(\+Args...)$>$}} }{\pageref{classstl_1_1function_3_01Ret_07Args_8_8_8_08_4}}{}
\item\contentsline{section}{\mbox{\hyperlink{structstl_1_1generic__const__iterator}{stl\+::generic\+\_\+const\+\_\+iterator$<$ T, linked\+\_\+list $>$}} \\*iterator but const }{\pageref{structstl_1_1generic__const__iterator}}{}
\item\contentsline{section}{\mbox{\hyperlink{structstl_1_1generic__iterator}{stl\+::generic\+\_\+iterator$<$ T, linked\+\_\+list $>$}} \\*Generic iterator container }{\pageref{structstl_1_1generic__iterator}}{}
\item\contentsline{section}{\mbox{\hyperlink{classstl_1_1hash}{stl\+::hash$<$ T $>$}} }{\pageref{classstl_1_1hash}}{}
\item\contentsline{section}{\mbox{\hyperlink{classsimula24_1_1LockGuard}{simula24\+::\+Lock\+Guard}} \\*Auto locks/unlocks mutexes Should only be used inside of functions }{\pageref{classsimula24_1_1LockGuard}}{}
\item\contentsline{section}{\mbox{\hyperlink{classsimula24_1_1Logger}{simula24\+::\+Logger}} \\*Logging Class }{\pageref{classsimula24_1_1Logger}}{}
\item\contentsline{section}{\mbox{\hyperlink{classsimula24_1_1Mutex}{simula24\+::\+Mutex}} \\*Mutual Exclusion }{\pageref{classsimula24_1_1Mutex}}{}
\item\contentsline{section}{\mbox{\hyperlink{structstl_1_1RefCountContainer}{stl\+::\+Ref\+Count\+Container}} \\*A simple container for holding a pointer and ~\newline
 the number of shared\+\_\+ptrs referencing it }{\pageref{structstl_1_1RefCountContainer}}{}
\item\contentsline{section}{\mbox{\hyperlink{structstl_1_1remove__reference}{stl\+::remove\+\_\+reference$<$ T $>$}} \\*This was mostly copied from the STL because it has very little performance over head ( if any) and is really the best way to implement perfect forwarding and movement }{\pageref{structstl_1_1remove__reference}}{}
\item\contentsline{section}{\mbox{\hyperlink{structstl_1_1remove__reference_3_01T_01_6_01_4}{stl\+::remove\+\_\+reference$<$ T \& $>$}} \\*Deduce type from reference }{\pageref{structstl_1_1remove__reference_3_01T_01_6_01_4}}{}
\item\contentsline{section}{\mbox{\hyperlink{structstl_1_1remove__reference_3_01T_01_6_6_01_4}{stl\+::remove\+\_\+reference$<$ T \&\& $>$}} \\*Deduce type from rvalue reference }{\pageref{structstl_1_1remove__reference_3_01T_01_6_6_01_4}}{}
\item\contentsline{section}{\mbox{\hyperlink{classstl_1_1shared__ptr}{stl\+::shared\+\_\+ptr$<$ T $>$}} \\*Generic Shared Pointer class }{\pageref{classstl_1_1shared__ptr}}{}
\item\contentsline{section}{\mbox{\hyperlink{unionstl_1_1variant_3_01typelist_3_01Types_8_8_8_01_4_01_4_1_1Storage}{stl\+::variant$<$ typelist$<$ Types... $>$ $>$\+::\+Storage}} }{\pageref{unionstl_1_1variant_3_01typelist_3_01Types_8_8_8_01_4_01_4_1_1Storage}}{}
\item\contentsline{section}{\mbox{\hyperlink{classsimula24_1_1thread}{simula24\+::thread}} \\*Basic Thread class }{\pageref{classsimula24_1_1thread}}{}
\item\contentsline{section}{\mbox{\hyperlink{classsimula24_1_1TileConfig}{simula24\+::\+Tile\+Config}} \\*Handles parsing of a tile sheet + its config }{\pageref{classsimula24_1_1TileConfig}}{}
\item\contentsline{section}{\mbox{\hyperlink{classsimula24_1_1TileSheet}{simula24\+::\+Tile\+Sheet}} \\*Represents a single tilesheet }{\pageref{classsimula24_1_1TileSheet}}{}
\item\contentsline{section}{\mbox{\hyperlink{structsimula24_1_1TileSheetConfig}{simula24\+::\+Tile\+Sheet\+Config}} \\*Represents data found in tileset.\+inf }{\pageref{structsimula24_1_1TileSheetConfig}}{}
\item\contentsline{section}{\mbox{\hyperlink{classsimula24_1_1TileSheetParser}{simula24\+::\+Tile\+Sheet\+Parser}} }{\pageref{classsimula24_1_1TileSheetParser}}{}
\item\contentsline{section}{\mbox{\hyperlink{structstl_1_1typelist}{stl\+::typelist$<$ Types $>$}} }{\pageref{structstl_1_1typelist}}{}
\item\contentsline{section}{\mbox{\hyperlink{classstl_1_1unique__ptr}{stl\+::unique\+\_\+ptr$<$ T $>$}} \\*Generic Unique Smart Pointer class }{\pageref{classstl_1_1unique__ptr}}{}
\item\contentsline{section}{\mbox{\hyperlink{classstl_1_1unordered__map}{stl\+::unordered\+\_\+map$<$ K, V, Hash $>$}} \\*An unordered hash map implementation using \textquotesingle{}Robin Hood\textquotesingle{} collision resolution }{\pageref{classstl_1_1unordered__map}}{}
\item\contentsline{section}{\mbox{\hyperlink{classstl_1_1variant}{stl\+::variant$<$ Types $>$}} }{\pageref{classstl_1_1variant}}{}
\item\contentsline{section}{\mbox{\hyperlink{classstl_1_1variant_3_01typelist_3_01Types_8_8_8_01_4_01_4}{stl\+::variant$<$ typelist$<$ Types... $>$ $>$}} \\*Variant, holds @\+Types types in a union Each of these functions is only enabled if the type passed to it is contained in the typelist. see typelist\+\_\+contains }{\pageref{classstl_1_1variant_3_01typelist_3_01Types_8_8_8_01_4_01_4}}{}
\end{DoxyCompactList}
