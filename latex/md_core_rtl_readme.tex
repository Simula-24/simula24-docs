\hypertarget{md_core_rtl_readme_autotoc_md1}{}\doxysection{Table of Contents}\label{md_core_rtl_readme_autotoc_md1}

\begin{DoxyEnumerate}
\item {\ttfamily \mbox{\hyperlink{classrtl_1_1copy__on__write}{rtl\+::copy\+\_\+on\+\_\+write}}}
\item {\ttfamily \mbox{\hyperlink{classrtl_1_1basic__string}{rtl\+::basic\+\_\+string}}}
\item {\ttfamily \mbox{\hyperlink{classrtl_1_1array}{rtl\+::array}}}
\item {\ttfamily \mbox{\hyperlink{classrtl_1_1unordered__map}{rtl\+::unordered\+\_\+map}}}
\item {\ttfamily rtl\+::iterator}
\end{DoxyEnumerate}\hypertarget{md_core_rtl_readme_autotoc_md2}{}\doxysubsection{rtl\+::copy\+\_\+on\+\_\+write}\label{md_core_rtl_readme_autotoc_md2}
This is a central component of the template library. {\itshape Most} data structures found here rely on COW. This allows data structures to be passed around, and only copied when modified. Ideally, this will happen implicitly, behind the scenes.

COW is a fairly simple data structure. It consists of\+:
\begin{DoxyEnumerate}
\item A reference count
\item An object size
\item A raw array of objects
\end{DoxyEnumerate}

This information is stored all together in a single heap allocation. 
\begin{DoxyCode}{0}
\DoxyCodeLine{0           32           64    }
\DoxyCodeLine{┌────────────┬───────────┬──────┐}
\DoxyCodeLine{│  Ref Count │ Data Size │ Data │    }
\DoxyCodeLine{└────────────┴───────────┴──────┘}

\end{DoxyCode}


Any functions that would modify the data (i.\+e, any non-\/const functions), will call {\ttfamily copy\+\_\+on\+\_\+write$<$T$>$\+::\+\_\+\+\_\+copy\+\_\+on\+\_\+write}.

The copy-\/constructor/copy-\/assignment operators will increase the reference count, while the destructors will decrease it If the destructor detects that the ref-\/count is 0 one of two things will happen\+:
\begin{DoxyEnumerate}
\item If the {\ttfamily T} is {\ttfamily std\+::\+\_\+\+\_\+is\+\_\+trivially\+\_\+destructable}, the destructor will loop through the array and call the destructores of its objects.
\end{DoxyEnumerate}
\begin{DoxyEnumerate}
\item Other wise it will simply free the memory
\end{DoxyEnumerate}\hypertarget{md_core_rtl_readme_autotoc_md3}{}\doxysubsection{rtl\+::basic\+\_\+string}\label{md_core_rtl_readme_autotoc_md3}
This class relies on a {\ttfamily copy\+\_\+on\+\_\+write} object.

This is basically just a clone of {\ttfamily std\+::string}.\hypertarget{md_core_rtl_readme_autotoc_md4}{}\doxysubsection{rtl\+::array}\label{md_core_rtl_readme_autotoc_md4}
This also relies on a {\ttfamily copy\+\_\+on\+\_\+write} object.\hypertarget{md_core_rtl_readme_autotoc_md5}{}\doxysubsection{rtl\+::unordered\+\_\+map}\label{md_core_rtl_readme_autotoc_md5}
This one was really fun to build.

This is the basic idea of a hash table\+:
\begin{DoxyEnumerate}
\item Use non-\/secure hashing algorithms to generate a 32-\/64 bit ID for an object {\ttfamily T}
\item Use the total size of the hash table to find and index based on the hash
\begin{DoxyItemize}
\item This typically involves finding the remainder e.\+g. \begin{DoxyVerb}  size_t index = hash_function(object) % totalsize;
\end{DoxyVerb}

\end{DoxyItemize}
\item Store the object or around that index.
\item During a look-\/up, hash the object, find it\textquotesingle{}s desired index, and look around for it.
\end{DoxyEnumerate}

This implementation uses the Robin Hood hash collosion resolution method (that is a mouthful).

Here is a psuedocode implementation\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{def insert(self, object):}
\DoxyCodeLine{    index = hash(object) \% m\_size}

\end{DoxyCode}
 