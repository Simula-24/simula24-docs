\hypertarget{md__doc_rtl_autotoc_md3}{}\doxysection{Table of Contents}\label{md__doc_rtl_autotoc_md3}

\begin{DoxyEnumerate}
\item {\ttfamily \mbox{\hyperlink{classrtl_1_1copy__on__write}{rtl\+::copy\+\_\+on\+\_\+write}}}
\item {\ttfamily \mbox{\hyperlink{classrtl_1_1basic__string}{rtl\+::basic\+\_\+string}}}
\item {\ttfamily \mbox{\hyperlink{classrtl_1_1array}{rtl\+::array}}}
\item {\ttfamily \mbox{\hyperlink{classrtl_1_1unordered__map}{rtl\+::unordered\+\_\+map}}}
\item {\ttfamily rtl\+::iterator}
\end{DoxyEnumerate}\hypertarget{md__doc_rtl_autotoc_md4}{}\doxysubsection{rtl\+::copy\+\_\+on\+\_\+write}\label{md__doc_rtl_autotoc_md4}
This is a central component of the template library. {\itshape Most} data structures found here rely on COW. This allows data structures to be passed around, and only copied when modified. Ideally, this will happen implicitly, behind the scenes.

COW is a fairly simple data structure. It consists of\+:
\begin{DoxyEnumerate}
\item A reference count
\item An object size
\item A raw array of objects
\end{DoxyEnumerate}

This information is stored all together in a single heap allocation. 
\begin{DoxyCode}{0}
\DoxyCodeLine{0           32           64    }
\DoxyCodeLine{┌────────────┬───────────┬──────┐}
\DoxyCodeLine{│  Ref Count │ Data Size │ Data │    }
\DoxyCodeLine{└────────────┴───────────┴──────┘}

\end{DoxyCode}


Any functions that would modify the data (i.\+e, any non-\/const functions), will call {\ttfamily copy\+\_\+on\+\_\+write$<$T$>$\+::\+\_\+\+\_\+copy\+\_\+on\+\_\+write}.

The copy-\/constructor/copy-\/assignment operators will increase the reference count, while the destructors will decrease it If the destructor detects that the ref-\/count is 0 one of two things will happen\+:
\begin{DoxyEnumerate}
\item If the {\ttfamily T} is {\ttfamily std\+::\+\_\+\+\_\+is\+\_\+trivially\+\_\+destructable}, the destructor will loop through the array and call the destructores of its objects.
\end{DoxyEnumerate}
\begin{DoxyEnumerate}
\item Other wise it will simply free the memory
\end{DoxyEnumerate}\hypertarget{md__doc_rtl_autotoc_md5}{}\doxysubsection{rtl\+::basic\+\_\+string}\label{md__doc_rtl_autotoc_md5}
This class relies on a {\ttfamily copy\+\_\+on\+\_\+write} object.

This is basically just a clone of {\ttfamily std\+::string}.\hypertarget{md__doc_rtl_autotoc_md6}{}\doxysubsection{rtl\+::array}\label{md__doc_rtl_autotoc_md6}
This also relies on a {\ttfamily copy\+\_\+on\+\_\+write} object.\hypertarget{md__doc_rtl_autotoc_md7}{}\doxysubsection{rtl\+::unordered\+\_\+map}\label{md__doc_rtl_autotoc_md7}
This one was really fun to build.

This is the basic idea of a hash table\+:
\begin{DoxyEnumerate}
\item Use non-\/secure hashing algorithms to generate a 32-\/64 bit ID for an object {\ttfamily T}
\item Use the total size of the hash table to find and index based on the hash
\begin{DoxyItemize}
\item This typically involves finding the remainder e.\+g. \begin{DoxyVerb}  size_t index = hash_function(object) % totalsize;
\end{DoxyVerb}

\end{DoxyItemize}
\item Store the object or around that index.
\item During a look-\/up, hash the object, find it\textquotesingle{}s desired index, and look around for it.
\end{DoxyEnumerate}\hypertarget{md__doc_rtl_autotoc_md8}{}\doxysubsection{rtl\+::generic\+\_\+iterator and rtl\+::generic\+\_\+const\+\_\+iterator}\label{md__doc_rtl_autotoc_md8}
These are generic iterators that should be used (and perhaps aliased) in your class.

This takes two parameters, the type that is iterated over, and {\ttfamily meminc}.

If {\ttfamily meminc} is set to true, the iterator will increment a pointer to your data.

Otherwise, it will operate on your data as if it is a doubly linked list. Thus, your data MUST provide a {\ttfamily next} and {\ttfamily prev} function.

{\ttfamily meminc} is on by default.\hypertarget{md__doc_rtl_autotoc_md9}{}\doxysubsection{rtl\+::function}\label{md__doc_rtl_autotoc_md9}
This is a type-\/erased functor object. It supports
\begin{DoxyEnumerate}
\item free-\/functions
\item Lambdas
\item Capturing lambdas
\end{DoxyEnumerate}

To use\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{ \{C++\}}
\DoxyCodeLine{}
\DoxyCodeLine{int add\_function(int a, int b)}
\DoxyCodeLine{\{}
\DoxyCodeLine{    return a + b;}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{// the template paramters are in the "{}ReturnType(Args)"{} format}
\DoxyCodeLine{rtl::function<int(int,int)> addFunctor(add\_function);}
\DoxyCodeLine{}
\DoxyCodeLine{// Call via}
\DoxyCodeLine{addFunctor(1, 2);}
\DoxyCodeLine{addFunctor(x,y);}
\DoxyCodeLine{}
\DoxyCodeLine{/// With lambdas}
\DoxyCodeLine{}
\DoxyCodeLine{rtl::function<void(int, int)> printAddFunctor(}
\DoxyCodeLine{    [](int a, int b)}
\DoxyCodeLine{    \{}
\DoxyCodeLine{        printf("{}\%d + \%d = \%d\(\backslash\)n"{}, a, b, a+b);}
\DoxyCodeLine{    \}}
\DoxyCodeLine{);}
\DoxyCodeLine{}
\DoxyCodeLine{// Functions with no arguments}
\DoxyCodeLine{}
\DoxyCodeLine{void enableTheThing()}
\DoxyCodeLine{\{}
\DoxyCodeLine{    ...}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{rtl::function<void()> enabler = enableTheThing;}

\end{DoxyCode}
\hypertarget{md__doc_rtl_autotoc_md10}{}\doxysubsection{rtl\+::shared\+\_\+ptr and rtl\+::unique\+\_\+ptr}\label{md__doc_rtl_autotoc_md10}
\hypertarget{md__doc_rtl_autotoc_md11}{}\doxysubsubsection{rtl\+::shared\+\_\+ptr}\label{md__doc_rtl_autotoc_md11}
A reference counted container for pointers

Create via {\ttfamily \mbox{\hyperlink{namespacertl_ab96afeae25e16a70257cb3ad5ac44e8e}{rtl\+::make\+\_\+shared}}$<$type$>$(constructor\+Args...);}

Access via overloaded {\ttfamily $\ast$} and {\ttfamily -\/$>$} operators.


\begin{DoxyCode}{0}
\DoxyCodeLine{struct mystruct}
\DoxyCodeLine{\{}
\DoxyCodeLine{    int x;}
\DoxyCodeLine{    int y;}
\DoxyCodeLine{}
\DoxyCodeLine{    mystruct(int \_x, int \_y) : x(\_x), y(\_y) \{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{rtl::shared\_ptr<mystruct> temp = rtl::make\_shared<mystruct>(1,2);}
\DoxyCodeLine{}
\DoxyCodeLine{assert(temp-\/>x == 1); // true}
\DoxyCodeLine{assert(temp-\/>y == 2); // true}
\DoxyCodeLine{}
\DoxyCodeLine{// increases ref count}
\DoxyCodeLine{rtl::shared\_ptr<mystruct> temp2 = temp;}

\end{DoxyCode}
\hypertarget{md__doc_rtl_autotoc_md12}{}\doxysubsubsection{rtl\+::unique\+\_\+ptr}\label{md__doc_rtl_autotoc_md12}
A container for a single, unique pointer

Create via {\ttfamily \mbox{\hyperlink{namespacertl_a486918a5acb16a52cd8f80dc8d8d118d}{rtl\+::make\+\_\+unique}}$<$type$>$(constructor\+Args...);}

Access via overloaded {\ttfamily $\ast$} and {\ttfamily -\/$>$} operators. 
\begin{DoxyCode}{0}
\DoxyCodeLine{struct mystruct}
\DoxyCodeLine{\{}
\DoxyCodeLine{    int x;}
\DoxyCodeLine{    int y;}
\DoxyCodeLine{}
\DoxyCodeLine{    mystruct(int \_x, int \_y) : x(\_x), y(\_y) \{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{rtl::unique\_ptr<mystruct> temp = rtl::make\_unique<mystruct>(1,2);}
\DoxyCodeLine{}
\DoxyCodeLine{assert(temp-\/>x == 1); // true}
\DoxyCodeLine{assert(temp-\/>y == 2); // true}
\DoxyCodeLine{}
\DoxyCodeLine{// moves temp to temp2}
\DoxyCodeLine{rtl::unique\_ptr<mystruct> temp2 = temp;}

\end{DoxyCode}
 