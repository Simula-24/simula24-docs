\hypertarget{namespacertl}{}\doxysection{rtl Namespace Reference}
\label{namespacertl}\index{rtl@{rtl}}
\doxysubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{classrtl_1_1array}{array}}
\begin{DoxyCompactList}\small\item\em array to hold T data \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classrtl_1_1basic__string}{basic\+\_\+string}}
\item 
class \mbox{\hyperlink{classrtl_1_1copy__on__write}{copy\+\_\+on\+\_\+write}}
\begin{DoxyCompactList}\small\item\em A template class that allows clients to ~\newline
 use copy-\/on-\/write. Use \mbox{\hyperlink{classrtl_1_1copy__on__write_a1053027fbbb6eca5ab9c9550532ae6fc}{copy()}} to create your own copy. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classrtl_1_1Callable}{Callable}}
\begin{DoxyCompactList}\small\item\em Base \mbox{\hyperlink{classrtl_1_1Callable}{Callable}} class Used for type-\/erasure. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classrtl_1_1CallableWrapper}{Callable\+Wrapper}}
\begin{DoxyCompactList}\small\item\em Wrapper around \mbox{\hyperlink{classrtl_1_1Callable}{Callable}}. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classrtl_1_1function}{function}}
\item 
class \mbox{\hyperlink{classrtl_1_1function_3_01Ret_07Args_8_8_8_08_4}{function$<$ Ret(\+Args...)$>$}}
\item 
class \mbox{\hyperlink{classrtl_1_1hash}{hash}}
\item 
class \mbox{\hyperlink{classrtl_1_1hash_3_01const_01char_01_5_01_4}{hash$<$ const char $\ast$ $>$}}
\item 
class \mbox{\hyperlink{classrtl_1_1hash_3_01string_01_4}{hash$<$ string $>$}}
\item 
class \mbox{\hyperlink{classrtl_1_1hash_3_01uint32__t_01_4}{hash$<$ uint32\+\_\+t $>$}}
\item 
class \mbox{\hyperlink{classrtl_1_1hash_3_01radium_1_1U64_01_4}{hash$<$ radium\+::\+U64 $>$}}
\item 
class \mbox{\hyperlink{classrtl_1_1hash_3_01int_01_4}{hash$<$ int $>$}}
\item 
class \mbox{\hyperlink{classrtl_1_1unordered__map}{unordered\+\_\+map}}
\begin{DoxyCompactList}\small\item\em An unordered hash map implementation using \textquotesingle{}Robin Hood\textquotesingle{} collision resolution. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structrtl_1_1displaced__pair}{displaced\+\_\+pair}}
\begin{DoxyCompactList}\small\item\em A specialized KV pair for maps/tables using PSLs. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structrtl_1_1generic__iterator}{generic\+\_\+iterator}}
\begin{DoxyCompactList}\small\item\em Generic iterator container. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structrtl_1_1generic__const__iterator}{generic\+\_\+const\+\_\+iterator}}
\begin{DoxyCompactList}\small\item\em iterator but const \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classrtl_1_1shared__ptr}{shared\+\_\+ptr}}
\begin{DoxyCompactList}\small\item\em Generic Shared Pointer class. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classrtl_1_1unique__ptr}{unique\+\_\+ptr}}
\begin{DoxyCompactList}\small\item\em Generic Unique Smart Pointer class. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structrtl_1_1remove__reference}{remove\+\_\+reference}}
\begin{DoxyCompactList}\small\item\em This was mostly copied from the STL because it has very little performance over head ( if any) and is really the best way to implement perfect forwarding and movement. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structrtl_1_1remove__reference_3_01T_01_6_01_4}{remove\+\_\+reference$<$ T \& $>$}}
\begin{DoxyCompactList}\small\item\em deduce type from reference \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structrtl_1_1remove__reference_3_01T_01_6_6_01_4}{remove\+\_\+reference$<$ T \&\& $>$}}
\begin{DoxyCompactList}\small\item\em deduce type from rvalue reference \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{namespacertl_acafc9ee382d8b707af53ca75d32f6704}\label{namespacertl_acafc9ee382d8b707af53ca75d32f6704}} 
using {\bfseries string} = \mbox{\hyperlink{classrtl_1_1basic__string}{basic\+\_\+string}}$<$ char $>$
\item 
\mbox{\Hypertarget{namespacertl_a5a773ba02d0ab11a5ee69a6548475040}\label{namespacertl_a5a773ba02d0ab11a5ee69a6548475040}} 
using {\bfseries wstring} = \mbox{\hyperlink{classrtl_1_1basic__string}{basic\+\_\+string}}$<$ wchar\+\_\+t $>$
\item 
\mbox{\Hypertarget{namespacertl_a42b3564b759732b3fcf430b6f275f600}\label{namespacertl_a42b3564b759732b3fcf430b6f275f600}} 
{\footnotesize template$<$class T $>$ }\\using \mbox{\hyperlink{namespacertl_a42b3564b759732b3fcf430b6f275f600}{remove\+\_\+reference\+\_\+t}} = typename \mbox{\hyperlink{structrtl_1_1remove__reference}{remove\+\_\+reference}}$<$ T $>$\+::type
\begin{DoxyCompactList}\small\item\em used as a function argument \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{namespacertl_ab96afeae25e16a70257cb3ad5ac44e8e}\label{namespacertl_ab96afeae25e16a70257cb3ad5ac44e8e}} 
{\footnotesize template$<$class T , class... Args$>$ }\\\mbox{\hyperlink{classrtl_1_1shared__ptr}{shared\+\_\+ptr}}$<$ T $>$ \mbox{\hyperlink{namespacertl_ab96afeae25e16a70257cb3ad5ac44e8e}{make\+\_\+shared}} (Args \&\&... args)
\begin{DoxyCompactList}\small\item\em Create a new shared pointer. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespacertl_a486918a5acb16a52cd8f80dc8d8d118d}\label{namespacertl_a486918a5acb16a52cd8f80dc8d8d118d}} 
{\footnotesize template$<$class T , class... Args$>$ }\\\mbox{\hyperlink{classrtl_1_1unique__ptr}{unique\+\_\+ptr}}$<$ T $>$ \mbox{\hyperlink{namespacertl_a486918a5acb16a52cd8f80dc8d8d118d}{make\+\_\+unique}} (Args... args)
\begin{DoxyCompactList}\small\item\em Create a new unique pointer. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespacertl_ad4871bba090762a6a51407d08381a8ce}\label{namespacertl_ad4871bba090762a6a51407d08381a8ce}} 
bool {\bfseries operator==} (const char $\ast$str1, const \mbox{\hyperlink{classbasic__string}{string}} \&str2)
\item 
\mbox{\Hypertarget{namespacertl_a1ae8c9e7b6e93007dd3b0eb4531ec075}\label{namespacertl_a1ae8c9e7b6e93007dd3b0eb4531ec075}} 
bool {\bfseries operator==} (const \mbox{\hyperlink{classbasic__string}{string}} \&str1, const \mbox{\hyperlink{classbasic__string}{string}} \&str2)
\item 
\mbox{\Hypertarget{namespacertl_a25aa1aecac3497bd8bf9848d87400b30}\label{namespacertl_a25aa1aecac3497bd8bf9848d87400b30}} 
bool {\bfseries operator!=} (const char $\ast$str1, const \mbox{\hyperlink{classbasic__string}{string}} \&str2)
\item 
\mbox{\Hypertarget{namespacertl_a5011aa9af08c8a5d7989d6b6ea5478f2}\label{namespacertl_a5011aa9af08c8a5d7989d6b6ea5478f2}} 
bool {\bfseries operator$>$} (const char $\ast$str1, const \mbox{\hyperlink{classbasic__string}{string}} \&str2)
\item 
\mbox{\Hypertarget{namespacertl_a7bb4884da437271b99a97c2b35dc23d3}\label{namespacertl_a7bb4884da437271b99a97c2b35dc23d3}} 
bool {\bfseries operator$<$} (const char $\ast$str1, const \mbox{\hyperlink{classbasic__string}{string}} \&str2)
\item 
\mbox{\Hypertarget{namespacertl_a1ce965a603b01a9a86b670a9ae5ee9d9}\label{namespacertl_a1ce965a603b01a9a86b670a9ae5ee9d9}} 
\mbox{\hyperlink{classbasic__string}{string}} \mbox{\hyperlink{namespacertl_a1ce965a603b01a9a86b670a9ae5ee9d9}{operator+}} (const char $\ast$str1, const \mbox{\hyperlink{classbasic__string}{string}} \&str2)
\begin{DoxyCompactList}\small\item\em append str1 to str2 \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespacertl_a37162529e1cd5e59c8501ffbe0a8ef4f}\label{namespacertl_a37162529e1cd5e59c8501ffbe0a8ef4f}} 
\mbox{\hyperlink{classbasic__string}{string}} {\bfseries operator+} (const \mbox{\hyperlink{classbasic__string}{string}} \&str1, const \mbox{\hyperlink{classbasic__string}{string}} \&str2)
\item 
{\footnotesize template$<$class T $>$ }\\constexpr T \&\& \mbox{\hyperlink{namespacertl_a75daea6490499de6dfd0f8c93eb0dccc}{forward}} (\mbox{\hyperlink{namespacertl_a42b3564b759732b3fcf430b6f275f600}{remove\+\_\+reference\+\_\+t}}$<$ T $>$ \&arg)
\begin{DoxyCompactList}\small\item\em end warning disable \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespacertl_ac087583e238d8e2125671ba1d4f2d79d}\label{namespacertl_ac087583e238d8e2125671ba1d4f2d79d}} 
{\footnotesize template$<$class T $>$ }\\constexpr T \&\& {\bfseries forward} (\mbox{\hyperlink{namespacertl_a42b3564b759732b3fcf430b6f275f600}{remove\+\_\+reference\+\_\+t}}$<$ T $>$ \&\&arg)
\item 
\mbox{\Hypertarget{namespacertl_a803c8b6ca60d13cc7478c1618822da25}\label{namespacertl_a803c8b6ca60d13cc7478c1618822da25}} 
{\footnotesize template$<$class T $>$ }\\constexpr \mbox{\hyperlink{structrtl_1_1remove__reference}{remove\+\_\+reference}}$<$ T $>$\+::type \&\& \mbox{\hyperlink{namespacertl_a803c8b6ca60d13cc7478c1618822da25}{move}} (T \&\&arg)
\begin{DoxyCompactList}\small\item\em Used in move semantics Will move stuff. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespacertl_a2fada11d9097d0bddffbdc1e074c6be8}\label{namespacertl_a2fada11d9097d0bddffbdc1e074c6be8}} 
{\footnotesize template$<$class T $>$ }\\constexpr void {\bfseries swap} (T \&l, T \&r)
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
This is the only STL library included in this project why? There are something we cannot do with fancy template metaprograming.

Instead we must rely on information provided by the compiler; information found in the type\+\_\+traits header 

\doxysubsection{Function Documentation}
\mbox{\Hypertarget{namespacertl_a75daea6490499de6dfd0f8c93eb0dccc}\label{namespacertl_a75daea6490499de6dfd0f8c93eb0dccc}} 
\index{rtl@{rtl}!forward@{forward}}
\index{forward@{forward}!rtl@{rtl}}
\doxysubsubsection{\texorpdfstring{forward()}{forward()}}
{\footnotesize\ttfamily template$<$class T $>$ \\
constexpr T\&\& rtl\+::forward (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespacertl_a42b3564b759732b3fcf430b6f275f600}{remove\+\_\+reference\+\_\+t}}$<$ T $>$ \&}]{arg }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [constexpr]}}



end warning disable 

T\& -\/$>$ T\&\& Used for perfect forwarding 